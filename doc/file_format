File format specification for a local storage module.

Storage is done in a flat file.
The file is append-only.

# Syntax

All content is stored as lines of text preceded and followed by \n.
The first byte of the file is \n.

JSON content stored as:
  JSON text + "\n"

Binary blobs stored as:
  base64-encoded blob + "\n"

(An alternate format is:
  blob_length + \n
  binary data (blob) + \n
  blob_length + \n
which allows both forward and backward per-line searches.
Base64 has the advantage that searching for "\n" is sufficient without adding logic to skip binary blobs. Node.js has native base64 encoding, we'll see if it is sufficient.)

"\n{" is the marker of a JSON record.

Empty lines are allowed and skipped.
(Generally speaking a block-write should start with a "\n" to
allow appending to a crashed database file.)

# Semantics

The document primarily stores the data.

The B-tree index(es) are also stored inside the file,
but they can be reconstructed from the data.

The root B-tree record is normally appended at the end of each block-write, making it the content of the last line of the file.

Binary blob writes and document writes can be mixed and intersped, allowing for fast appends. (A long attachment will be broken in multiple binary blobs.)

The same format is used to cache the result of views, lists, etc.

## Types of JSON records

### Documents (user JSON records)

Database documents are stored as-is.

Especially this allows to stream documents directly to the user.
(Let's call this "what-you-store-is-what-you-GET".)

Each new revision is stored as a new entry.

Updates (e.g. to the _rev, _attachments, attachment_md5 fields) are done during write.

### Attachments

Attachments are stored as special JSON records.

Here's a possible layout:

  _id: document id that contains the attachemnt
  _attachment_name: name of the attachment (document ID)
  length:     # Content-Length
  revpos      # The revision position that PUT this attachment.
  md5
  blobs: [ {start:,loc:}, ...]

The _attachment_name indicates that this record is an attachment.

The blobs list contains the start position (offset) of the given block in the attachment (the first start value is therefor 0); the "loc" field indicated the position of the corresponding blob in the database file (as an offset in that file).

Since the database is append-only the attachments are never modified.

There will probably be some kind of index for attachment.

### Change

Change records are stored as special JSON records.
(Probably "what-you-store-is-what-you-GET" as well.)

Possible layout:
  seq  -- database-global, starts at 1
  id
  changes
  deleted: boolean

There will probably be some kind of index for change records.

### Local documents

Stored as-is.

There will probably be some kind of index for local documents.

### Indexes

FIXME This section needs more work.

The B-trees are stored as JSON as well:
  {
    root: boolean
    nodes: [ pointer, record, pointer, ... ]
    records: [ record, record, ... ]
  }

"nodes" is used in intermediary (split) nodes.
"records" is used in bottom (no-descendent) nodes.

record:
  key:
    * in a document DB:
      document    =>  qs.escape(_id)
      change      =>  qs.escape(_id)?rev=#{rev}
      local_doc   =>  _local/qs.escape(name)
      attachment  =>  qs.escape(_id)/qs.escape(name)
    * in a view DB: string or object or number

  # For a document
  id: string   _id
  rev: string  _rev
  start: integer; most recent rev prefix (see "_revisions")
    start = revisions.length
  loc: to the corresponding ("latest") doc_rev
  conflicts
  deleted_conflicts

  # For a doc_rev
  id
  rev
  revisions: 
    [ uuid:, uuid:, uuid:, ... ]  # note: the actual rev = #{index+1} + '-' + uuid
  doc: pointer # to the document blob
  length:     # Content-Length
  etag: string # md5
  deleted: boolean
  revs_info

  # For a local_doc
  name: string  # for an attachment or local_doc
  local: boolean  # true for local_doc
  doc: pointer                  # for a document or local_doc

  # For a view document:
  id: string
  pointer: to the corresponding "value" JSON record.

# Appendix

FIXME Misc notes.

attachment:

in the document blob itself:

  _attachments: [] of
    #name :
      content_type
      data  # if base64
      stub:true, length:#length # if stub


pointer is an integer representing the offset (in bytes) from the start of the file


views use the same format
  they are created by a (separate) process that listens to _changes


